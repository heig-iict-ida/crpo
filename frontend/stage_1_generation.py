from kivy.uix.screenmanager import Screen
from kivy.lang import Builder
from kivy.clock import Clock

from utils.utils import log, mv_back, mv_next, mv_next_create
from frontend.stage_2_theme import StageThemeScreen
from frontend.stage_manual_edition import StageManualEditionScreen
from backend.generer_poesie import syllable_count_sentence

import utils.config as conf
if (conf.prod_models):
	from backend.generer_poesie import generate_poetry

with open('frontend/widgets.kv', encoding='utf8') as f:
	Builder.load_string(f.read())
with open('frontend/screen_1_generation.kv', encoding='utf8') as f:
	Builder.load_string(f.read())

stage_name = "1.0-ONE-GENERATION"
#STAGE ONE (1.0)
#Form selection
class StageGenerationScreen(Screen):
	_format = "quatrain" #(default when no click yet)
	params = ""
	txt_intro = "Choose the form of the poem that will be \ngenerated by my artificial intelligence."
	txt_wait = "Generating a poem: please wait.\nI am busy with complex calculations."
	txt_wait_poem = "Creation in progress..."
	txt_result = "Here is my proposal: it may not be perfect,\nso feel free to edit it as you like."
	txt_syllables = "Please enter at most 7 syllables:"
	txt_syllables_original = "Enter here the first words if you wish:"

	def __init__(self, user, main_model, thematic_models, emotion_models, state, **kwargs):
		super(StageGenerationScreen, self).__init__(**kwargs)
		self.user = user
		self.main_model = main_model
		self.thematic_models = thematic_models
		self.emotion_models = emotion_models
		self._main_txt.text = self.txt_intro
		self._txt_poem.text = state.get("poem", "")
		self._btn_edit.disabled = state.get("buttons_disabled", True)
		self._btn_next.disabled = state.get("buttons_disabled", True)

		poem_format = state.get("format", 3) # defaults to quatrain
		id_format = -1
		if poem_format == 'quatrain':
			id_format = 3
		elif poem_format == 'haiku':
			id_format = 2
		elif poem_format == 'sonnet':
			id_format = 1
		elif poem_format == 'freeform':
			id_format = 0

		for child in self.togglegroup.children:
			child.disabled = False
			child.state = 'normal'

		self.togglegroup.children[id_format].disabled = True
		self.togglegroup.children[id_format].state = 'down'

		self.user.write_file_stage_start(stage_name, self._txt_poem.text)


	# DEPRECATED
	def _notify_change_settings(self):
		if (self._format != ""): #enable send only if a format has been choosen
			self._btn_gen.disabled = False

	def btn_format(self, btn, txt):
		self._format = txt
		self._notify_change_settings()

		#disallow unselection of just selected radio button
		for i in self.togglegroup.children:
			i.disabled = False
		btn.disabled = True

	def btn_gen_press(self, btn):
		if(syllable_count_sentence(self._usr_input.text) <= 7) :
			btn.disabled = True
			self._btn_edit.disabled = True
			self._btn_next.disabled = True
			self.ui_able()

			self._main_txt.text = self.txt_wait
			self._txt_poem.text = self.txt_wait_poem
			self._input_txt.text = self.txt_syllables_original
		else:
			self._input_txt.text = self.txt_syllables

	def btn_gen_release(self, btn):
		if(syllable_count_sentence(self._usr_input.text) <= 7) :
			Clock.schedule_once(self.gen, 0.1)

	def ui_able(self, disabled = True):
		for i in self.togglegroup.children:
			i.disabled = disabled
			#disable the currently selected toggle button to mimic real radio button (no-selection is impossible)
			if (i.state == 'down' and disabled == False):
				i.disabled = True
		#TODO: eventl set grey the slider labels ?

	def gen(self, dt):
		text = ""
		self.params = '['+ self._format + ']' 
		if (conf.prod_models):
			#actual interaction (with actual values for format and mixing numbers)
			text = generate_poetry(models=self.main_model,
				form=self._format,
				debug=False,
				temperature=conf.TEMPERATURE_GENERAL,
				user_input=self._usr_input.text)
		else: #fake texts for faster tests only #all, tristesse, nature, art, spiritualite, amour'
			text = "Identifiant (mock): " + self.user.getID() \
			+ "\nStage ONE 1.0 : Form"  \
			+ "\n Format: " + self._format

		self._btn_gen.disabled = False
		self._btn_edit.disabled = False
		self._btn_next.disabled = False
		self.ui_able(disabled = False)

		self._txt_poem.text = text
		self._main_txt.text = self.txt_result
		self._btn_gen.text = "Regenerate a poem"
		
		# write the intermediate result from back-end
		self.user.write_file_stage_interm(stage_name, self._txt_poem.text, v_param = self.params)

		#TODO : DB-DEPRECATED
		#saves the draft data to db (without forward)
		self.user.write(self._txt_poem.text, v_param = self.params, forward = False)

	def btn_edit(self, btn):
		btn.disabled = True
		
		#No write needed here - it has been written with the current version when recieved from backend
		#It will be written again when exiting edition (either definitive with next, either cancels the draft with back key)

		#move to edition stage with come-back option
		_name = "StageManualEditionScreen"
		current_state = {
			"poem": self._txt_poem.text,
			"format": self._format,
			"origin": 1
		}
		mv_next_create(self.manager,
			_name,
			StageManualEditionScreen(name=_name,
				user=self.user,
				main_model=self.main_model,
				thematic_models=self.thematic_models,
				emotion_models=self.emotion_models,
				state=current_state))

	def btn_next(self, btn):
		btn.disabled = True
		
		#Write the current version as definitive.
		self.user.write_file_stage_end(stage_name, self._txt_poem.text, "NEXT-STAGE")
		
		#TODO : DB-DEPRECATED
		#write data to db (and forward)
		self.user.write(self._txt_poem.text, v_param = self.params, forward = True)

		#move forward to next stage
		_name = "StageThemeScreen"
		current_state = {
			"poem": self._txt_poem.text,
		}
		
		mv_next_create(self.manager,
			_name,
			StageThemeScreen(name=_name,
				user=self.user,
				main_model=self.main_model,
				thematic_models=self.thematic_models,
				emotion_models=self.emotion_models,
				state=current_state))

	#on slider value change => notify settings change
	# DEPRECATED
	def sld_change(self, slider):
		self._notify_change_settings()
		return True
